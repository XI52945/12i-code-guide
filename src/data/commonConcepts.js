export const commonConcepts = [
  // 基础概念 Basic Concepts
  { term: 'Algorithm', definition: '算法，解决问题的步骤。', example: '排序算法，搜索算法。', type: '基础概念' },
  { term: 'Data Structure', definition: '数据结构，组织和存储数据的方式。', example: '数组，链表，树，图。', type: '基础概念' },
  { term: 'API', definition: 'Application Programming Interface，应用程序接口。', example: 'REST API, GraphQL。', type: '基础概念' },
  { term: 'IDE', definition: 'Integrated Development Environment，集成开发环境。', example: 'VS Code, IntelliJ IDEA。', type: '基础概念' },
  { term: 'Bug', definition: '程序中的错误或缺陷。', example: '逻辑错误，语法错误。', type: '基础概念' },
  { term: 'Debugging', definition: '调试，查找和修复 Bug 的过程。', example: '使用断点，打印日志。', type: '基础概念' },
  { term: 'Compiler', definition: '编译器，将源代码转换为机器代码的程序。', example: 'GCC, Clang, javac。', type: '基础概念' },
  { term: 'Interpreter', definition: '解释器，直接执行源代码的程序。', example: 'Python, Node.js。', type: '基础概念' },
  { term: 'Framework', definition: '框架，提供了一套标准的代码结构和工具。', example: 'React, Spring Boot, Django。', type: '基础概念' },
  { term: 'Library', definition: '库，提供特定功能的代码集合。', example: 'Lodash, NumPy。', type: '基础概念' },
  { term: 'Source Code', definition: '源代码，程序员编写的文本文件。', example: '.js, .py, .java 文件。', type: '基础概念' },
  { term: 'Open Source', definition: '开源，源代码公开，允许任何人查看、修改和分发。', example: 'Linux, React, VS Code。', type: '基础概念' },
  { term: 'Version Control', definition: '版本控制，管理代码变更的系统。', example: 'Git, SVN。', type: '基础概念' },
  { term: 'Repository', definition: '仓库，存储代码和版本历史的地方。', example: 'GitHub Repo。', type: '基础概念' },
  { term: 'Commit', definition: '提交，保存代码变更的操作。', example: 'git commit -m "fix bug"', type: '基础概念' },
  { term: 'Refactoring', definition: '重构，在不改变代码外在行为的前提下，改善其内部结构。', example: '提取函数，重命名变量。', type: '基础概念' },
  { term: 'Technical Debt', definition: '技术债务，为了短期速度而牺牲代码质量所带来的代价。', example: '快速上线但代码混乱，后期维护成本高。', type: '基础概念' },

  // 操作系统 Operating Systems
  { term: 'Kernel', definition: '内核，操作系统的核心，管理硬件和软件资源。', example: 'Linux Kernel, Windows NT Kernel。', type: '操作系统' },
  { term: 'Shell', definition: '壳层，用户与操作系统内核交互的界面。', example: 'Bash, Zsh, PowerShell。', type: '操作系统' },
  { term: 'Process', definition: '进程，正在运行的程序的实例。', example: '任务管理器中看到的 Chrome 进程。', type: '操作系统' },
  { term: 'Thread', definition: '线程，进程中的执行单元，轻量级进程。', example: '多线程下载。', type: '操作系统' },
  { term: 'Deadlock', definition: '死锁，两个或多个进程互相等待对方释放资源，导致无法继续执行。', example: '哲学家进餐问题。', type: '操作系统' },
  { term: 'Concurrency', definition: '并发，多个任务在重叠的时间段内执行。', example: '单核 CPU 通过时间片轮转执行多任务。', type: '操作系统' },
  { term: 'Parallelism', definition: '并行，多个任务在同一时刻同时执行。', example: '多核 CPU 同时处理多个任务。', type: '操作系统' },
  { term: 'Virtual Memory', definition: '虚拟内存，使用硬盘空间模拟 RAM，让程序认为有连续可用的内存。', example: 'Pagefile, Swap。', type: '操作系统' },
  { term: 'System Call', definition: '系统调用，程序向操作系统内核请求服务。', example: 'open(), read(), fork()。', type: '操作系统' },

  // 数据库 Database
  { term: 'SQL', definition: 'Structured Query Language，结构化查询语言。', example: 'SELECT * FROM users;', type: '数据库' },
  { term: 'NoSQL', definition: 'Not Only SQL，非关系型数据库。', example: 'MongoDB, Redis, Cassandra。', type: '数据库' },
  { term: 'ACID', definition: '原子性、一致性、隔离性、持久性，事务的四个特性。', example: '银行转账必须满足 ACID。', type: '数据库' },
  { term: 'CAP Theorem', definition: 'CAP 定理，分布式系统无法同时满足一致性 (C)、可用性 (A) 和分区容错性 (P)。', example: '通常只能满足 CP 或 AP。', type: '数据库' },
  { term: 'Normalization', definition: '范式化，组织数据库以减少冗余和依赖。', example: '第一范式 (1NF), 第三范式 (3NF)。', type: '数据库' },
  { term: 'Indexing', definition: '索引，提高数据库查询速度的数据结构。', example: 'B+ Tree Index, Hash Index。', type: '数据库' },
  { term: 'Transaction', definition: '事务，一系列操作作为单个逻辑单元执行。', example: '要么全部成功，要么全部回滚。', type: '数据库' },
  { term: 'Sharding', definition: '分片，将数据水平拆分到多个数据库实例。', example: '按用户 ID 取模分库。', type: '数据库' },
  { term: 'Replication', definition: '复制，将数据拷贝到多个节点以提高可用性。', example: '主从复制 (Master-Slave)。', type: '数据库' },
  { term: 'ORM', definition: 'Object-Relational Mapping，对象关系映射。', example: 'Hibernate, Sequelize, TypeORM。', type: '数据库' },

  // 架构 Architecture
  { term: 'Monolith', definition: '单体架构，所有功能打包在一个应用程序中。', example: '早期的 Web 应用。', type: '架构' },
  { term: 'Microservices', definition: '微服务架构，将应用拆分为一组小型、独立的服务。', example: 'Netflix, Uber 的架构。', type: '架构' },
  { term: 'Serverless', definition: '无服务器架构，开发者只需关注代码，无需管理服务器。', example: 'AWS Lambda, Vercel Functions。', type: '架构' },
  { term: 'REST', definition: 'Representational State Transfer，表现层状态转换。', example: 'GET /users/1', type: '架构' },
  { term: 'GraphQL', definition: '一种用于 API 的查询语言。', example: 'query { user(id: 1) { name } }', type: '架构' },
  { term: 'RPC', definition: 'Remote Procedure Call，远程过程调用。', example: 'gRPC, JSON-RPC。', type: '架构' },
  { term: 'MVC', definition: 'Model-View-Controller，模型-视图-控制器模式。', example: 'Spring MVC, Ruby on Rails。', type: '架构' },
  { term: 'Event-Driven', definition: '事件驱动架构，通过事件的生产和消费来通信。', example: 'Kafka, RabbitMQ。', type: '架构' },
  { term: 'Load Balancer', definition: '负载均衡器，在多个服务器之间分配流量。', example: 'Nginx, HAProxy, AWS ELB。', type: '架构' },

  // 安全 Security
  { term: 'XSS', definition: 'Cross-Site Scripting，跨站脚本攻击。', example: '注入恶意脚本到网页中。', type: '安全' },
  { term: 'CSRF', definition: 'Cross-Site Request Forgery，跨站请求伪造。', example: '诱导用户执行非本意的操作。', type: '安全' },
  { term: 'SQL Injection', definition: 'SQL 注入，通过输入恶意 SQL 代码攻击数据库。', example: "' OR '1'='1", type: '安全' },
  { term: 'Encryption', definition: '加密，将明文转换为密文。', example: 'AES, RSA。', type: '安全' },
  { term: 'Authentication', definition: '认证，验证用户身份。', example: '登录 (用户名/密码)。', type: '安全' },
  { term: 'Authorization', definition: '授权，验证用户是否有权限执行操作。', example: '管理员权限 vs 普通用户权限。', type: '安全' },
  { term: 'Hashing', definition: '哈希，将任意长度的数据映射为固定长度的字符串。', example: 'MD5, SHA-256 (用于存储密码)。', type: '安全' },
  { term: 'OAuth', definition: 'Open Authorization，开放授权标准。', example: '使用 Google/GitHub 账号登录第三方网站。', type: '安全' },
  { term: 'JWT', definition: 'JSON Web Token，用于安全传输信息的紧凑、自包含的方式。', example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...', type: '安全' },
  { term: 'Public Key', definition: '公钥，用于加密数据或验证签名，公开给任何人。', example: 'RSA 公钥。', type: '安全' },
  { term: 'Private Key', definition: '私钥，用于解密数据或签名，必须保密。', example: 'RSA 私钥。', type: '安全' },
  { term: 'Firewall', definition: '防火墙，网络安全系统，监控和控制网络流量。', example: '阻止未经授权的访问。', type: '安全' },
  { term: 'VPN', definition: 'Virtual Private Network，虚拟专用网络。', example: '在公共网络上建立安全连接。', type: '安全' },
  { term: 'DDoS', definition: 'Distributed Denial of Service，分布式拒绝服务攻击。', example: '利用大量僵尸网络流量淹没目标服务器。', type: '安全' },
  { term: 'Phishing', definition: '网络钓鱼，欺骗用户泄露敏感信息。', example: '伪造的银行邮件链接。', type: '安全' },
  { term: 'Man-in-the-Middle', definition: '中间人攻击，攻击者拦截并篡改通信。', example: '在公共 Wi-Fi 窃取数据。', type: '安全' },

  // 网络 Networking
  { term: 'HTTP', definition: 'HyperText Transfer Protocol，超文本传输协议。', example: '网页浏览的基础。', type: '网络' },
  { term: 'HTTPS', definition: 'HTTP Secure，安全的 HTTP，使用 SSL/TLS 加密。', example: '带有小锁图标的网站。', type: '网络' },
  { term: 'WebSocket', definition: '全双工通信协议，允许服务器主动向客户端推送数据。', example: '在线聊天室。', type: '网络' },
  { term: 'TCP/IP', definition: 'Transmission Control Protocol/Internet Protocol，互联网的基础协议。', example: '数据传输的规则。', type: '网络' },
  { term: 'DNS', definition: 'Domain Name System，域名系统。', example: '将 google.com 解析为 142.250.190.46。', type: '网络' },
  { term: 'IP Address', definition: '互联网协议地址，设备的唯一标识。', example: '192.168.1.1 (IPv4), 2001:db8::1 (IPv6)。', type: '网络' },
  { term: 'Port', definition: '端口，区分同一台计算机上不同服务的数字标识。', example: '80 (HTTP), 443 (HTTPS), 22 (SSH)。', type: '网络' },
  { term: 'Router', definition: '路由器，连接不同网络并转发数据包的设备。', example: '家里的 Wi-Fi 路由器。', type: '网络' },
  { term: 'Subnet Mask', definition: '子网掩码，区分 IP 地址的网络部分和主机部分。', example: '255.255.255.0', type: '网络' },
  { term: 'DHCP', definition: 'Dynamic Host Configuration Protocol，动态主机配置协议。', example: '自动给设备分配 IP 地址。', type: '网络' },
  { term: 'NAT', definition: 'Network Address Translation，网络地址转换。', example: '让内网多个设备共享一个公网 IP。', type: '网络' },
  { term: 'Proxy', definition: '代理服务器，充当客户端和服务器之间的中介。', example: 'VPN 也是一种代理。', type: '网络' },
  { term: 'FTP', definition: 'File Transfer Protocol，文件传输协议。', example: '用于上传下载文件。', type: '网络' },

  // 移动开发 Mobile
  { term: 'Native App', definition: '原生应用，为特定平台（iOS/Android）开发的应用程序。', example: 'Swift (iOS), Kotlin (Android)。', type: '移动开发' },
  { term: 'Hybrid App', definition: '混合应用，结合 Web 技术和原生功能的应用程序。', example: 'Ionic, Cordova。', type: '移动开发' },
  { term: 'Cross-Platform', definition: '跨平台开发，一套代码运行在多个平台。', example: 'React Native, Flutter, Xamarin。', type: '移动开发' },
  { term: 'APK', definition: 'Android Package Kit，安卓应用安装包。', example: 'app-release.apk', type: '移动开发' },
  { term: 'IPA', definition: 'iOS App Store Package，iOS 应用安装包。', example: 'app.ipa', type: '移动开发' },
  { term: 'WebView', definition: '在原生应用中显示网页的组件。', example: 'React Native 的 <WebView />。', type: '移动开发' },
  { term: 'Manifest', definition: '清单文件，描述应用基本信息。', example: 'AndroidManifest.xml, Info.plist。', type: '移动开发' },
  { term: 'Gradle', definition: 'Android 的构建自动化工具。', example: 'build.gradle', type: '移动开发' },
  { term: 'CocoaPods', definition: 'iOS 的依赖管理工具。', example: 'Podfile', type: '移动开发' },

  // 人工智能 AI & Data
  { term: 'Artificial Intelligence (AI)', definition: '人工智能，模拟人类智能的机器系统。', example: 'Siri, ChatGPT, AlphaGo。', type: '人工智能' },
  { term: 'Machine Learning (ML)', definition: '机器学习，让计算机从数据中学习规律。', example: '垃圾邮件分类，推荐系统。', type: '人工智能' },
  { term: 'Deep Learning', definition: '深度学习，基于人工神经网络的机器学习。', example: '图像识别，自然语言处理。', type: '人工智能' },
  { term: 'Neural Network', definition: '神经网络，模拟人脑神经元结构的计算模型。', example: 'CNN (卷积神经网络), RNN (循环神经网络)。', type: '人工智能' },
  { term: 'NLP', definition: 'Natural Language Processing，自然语言处理。', example: '机器翻译，情感分析。', type: '人工智能' },
  { term: 'Big Data', definition: '大数据，无法用常规软件处理的海量数据。', example: 'Hadoop, Spark。', type: '人工智能' },
  { term: 'Data Mining', definition: '数据挖掘，从大量数据中发现模式和知识。', example: '超市发现"啤酒与尿布"的关联。', type: '人工智能' },
  { term: 'LLM', definition: 'Large Language Model，大型语言模型。', example: 'GPT-4, Claude, Llama。', type: '人工智能' },
  { term: 'RAG', definition: 'Retrieval-Augmented Generation，检索增强生成。', example: '结合知识库的 AI 问答。', type: '人工智能' },
  { term: 'Fine-tuning', definition: '微调，在特定数据集上进一步训练预训练模型。', example: '让 AI 学习特定行业知识。', type: '人工智能' },

  // 软技能与敏捷 Soft Skills & Agile
  { term: 'Agile', definition: '敏捷开发，迭代式、增量式的软件开发方法。', example: '拥抱变化，快速交付。', type: '软技能' },
  { term: 'Scrum', definition: '一种敏捷开发框架，强调团队协作。', example: 'Sprint (冲刺), Daily Stand-up (每日站会)。', type: '软技能' },
  { term: 'Kanban', definition: '看板，可视化工作流程的管理方法。', example: 'Trello, Jira 的看板视图 (To Do, Doing, Done)。', type: '软技能' },
  { term: 'User Story', definition: '用户故事，从用户角度描述需求。', example: '作为用户，我想要...以便...', type: '软技能' },
  { term: 'MVP', definition: 'Minimum Viable Product，最小可行性产品。', example: '只包含核心功能的产品，用于验证市场。', type: '软技能' },
  { term: 'Pair Programming', definition: '结对编程，两个程序员共用一台电脑编写代码。', example: '一人写代码(Driver)，一人审查(Navigator)。', type: '软技能' },
  { term: 'Stand-up Meeting', definition: '站会，每日短会，同步进度。', example: '昨天做了什么？今天计划做什么？有什么阻碍？', type: '软技能' },
  { term: 'Retrospective', definition: '回顾会，项目结束后总结经验教训。', example: '做得好的，做得不好的，改进措施。', type: '软技能' },
  { term: 'Soft Skills', definition: '软技能，非技术技能，如沟通、协作、领导力。', example: '团队合作，时间管理。', type: '软技能' },
  { term: 'Code Review', definition: '代码审查，同行评审代码以发现问题。', example: 'GitHub Pull Request Review。', type: '软技能' },

  // 云计算 & DevOps
  { term: 'Cloud Computing', definition: '云计算，通过互联网提供计算资源。', example: 'AWS, Azure, Google Cloud。', type: '云计算' },
  { term: 'IaaS', definition: 'Infrastructure as a Service，基础设施即服务。', example: 'AWS EC2, Google Compute Engine。', type: '云计算' },
  { term: 'PaaS', definition: 'Platform as a Service，平台即服务。', example: 'Heroku, Google App Engine, Vercel。', type: '云计算' },
  { term: 'SaaS', definition: 'Software as a Service，软件即服务。', example: 'Google Docs, Salesforce, Slack。', type: '云计算' },
  { term: 'Virtualization', definition: '虚拟化，在硬件上创建虚拟资源的技术。', example: 'VMware, VirtualBox。', type: '云计算' },
  { term: 'Container', definition: '容器，轻量级的虚拟化技术，打包应用及其依赖。', example: 'Docker 容器。', type: '云计算' },
  { term: 'Orchestration', definition: '编排，自动化容器的部署、扩展和管理。', example: 'Kubernetes (K8s)。', type: '云计算' },
  { term: 'CI/CD', definition: 'Continuous Integration / Continuous Delivery，持续集成/持续交付。', example: 'Jenkins, GitHub Actions, GitLab CI。', type: '云计算' },
  { term: 'IaC', definition: 'Infrastructure as Code，基础设施即代码。', example: 'Terraform, Ansible, CloudFormation。', type: '云计算' },

  // Web 技术
  { term: 'Cookie', definition: '存储在用户浏览器中的小型数据片段。', example: '用于保持登录状态。', type: 'Web开发' },
  { term: 'Session', definition: '服务器端存储的用户会话信息。', example: '购物车数据。', type: 'Web开发' },
  { term: 'Cache', definition: '缓存，临时存储数据以加快访问速度。', example: '浏览器缓存，Redis 缓存。', type: 'Web开发' },
  { term: 'CDN', definition: 'Content Delivery Network，内容分发网络。', example: '加速图片和视频加载。', type: 'Web开发' },
  { term: 'Responsive Design', definition: '响应式设计，网页自动适应不同屏幕尺寸。', example: 'Bootstrap, Tailwind CSS。', type: 'Web开发' },
  { term: 'SPA', definition: 'Single Page Application，单页应用。', example: 'React, Vue, Angular 应用。', type: 'Web开发' },
  { term: 'SSR', definition: 'Server-Side Rendering，服务端渲染。', example: 'Next.js, Nuxt.js。', type: 'Web开发' },
  { term: 'SSG', definition: 'Static Site Generation，静态站点生成。', example: 'Gatsby, Jekyll, Hugo。', type: 'Web开发' },
  { term: 'PWA', definition: 'Progressive Web App，渐进式 Web 应用。', example: '可安装到桌面的 Web 应用。', type: 'Web开发' },

  // 测试 Testing
  { term: 'Unit Testing', definition: '单元测试，测试代码的最小单元（函数/类）。', example: 'Jest, JUnit。', type: '测试' },
  { term: 'Integration Testing', definition: '集成测试，测试多个组件之间的交互。', example: '测试数据库连接。', type: '测试' },
  { term: 'E2E Testing', definition: 'End-to-End Testing，端到端测试，模拟用户真实操作。', example: 'Cypress, Selenium。', type: '测试' },
  { term: 'TDD', definition: 'Test-Driven Development，测试驱动开发。', example: '先写测试，再写代码。', type: '测试' },
  { term: 'Mocking', definition: '模拟，用模拟对象代替真实对象进行测试。', example: '模拟 API 响应。', type: '测试' },

  // 硬件 Hardware
  { term: 'CPU', definition: 'Central Processing Unit，中央处理器，计算机的大脑。', example: 'Intel Core i7, Apple M1。', type: '硬件' },
  { term: 'RAM', definition: 'Random Access Memory，随机存取存储器，临时存储运行数据。', example: '16GB DDR4 内存。', type: '硬件' },
  { term: 'GPU', definition: 'Graphics Processing Unit，图形处理器，处理图像和并行计算。', example: 'NVIDIA RTX 3080。', type: '硬件' },
  { term: 'SSD', definition: 'Solid State Drive，固态硬盘，高速存储设备。', example: 'NVMe SSD。', type: '硬件' },
  { term: 'IoT', definition: 'Internet of Things，物联网。', example: '智能家居，传感器。', type: '硬件' },

  // 数据结构 Data Structures (from structures.js)
  { term: '数组 (Array)', definition: '连续内存分配，O(1) 随机访问，O(n) 插入/删除。', example: 'const arr = [1, 2, 3];\narr.push(4); // O(1)\narr.splice(1, 1); // O(n)', type: '数据结构' },
  { term: '链表 (Linked List)', definition: '节点通过指针连接，O(1) 插入/删除（已知位置），O(n) 查找。', example: 'class Node { constructor(val) { this.val = val; this.next = null; } }', type: '数据结构' },
  { term: '栈 (Stack)', definition: '后进先出 (LIFO)。', example: 'const stack = [];\nstack.push(1);\nconst top = stack.pop();', type: '数据结构' },
  { term: '队列 (Queue)', definition: '先进先出 (FIFO)。', example: 'const queue = [];\nqueue.push(1);\nconst front = queue.shift(); // O(n) unless using linked list', type: '数据结构' },
  { term: '双端队列 (Deque)', definition: '两端都可插入和删除。', example: 'Python: collections.deque\nJava: ArrayDeque', type: '数据结构' },
  { term: '哈希表 (Hash Table)', definition: '通过哈希函数映射键到索引，平均 O(1) 查找/插入/删除。', example: 'const map = new Map();\nmap.set("key", "value");\nmap.get("key");', type: '数据结构' },
  { term: '二叉树 (Binary Tree)', definition: '每个节点最多有两个子节点。', example: 'class TreeNode { constructor(val) { this.val = val; this.left = this.right = null; } }', type: '数据结构' },
  { term: '二叉搜索树 (BST)', definition: '左子树 < 根 < 右子树，O(log n) 查找（平衡时）。', example: 'function search(root, val) {\n  if (!root || root.val === val) return root;\n  return val < root.val ? search(root.left, val) : search(root.right, val);\n}', type: '数据结构' },
  { term: '堆 (Heap)', definition: '完全二叉树，根节点最大(大顶堆)或最小(小顶堆)。', example: '用于优先队列 (Priority Queue)，Top K 问题。', type: '数据结构' },
  { term: '字典树 (Trie)', definition: '前缀树，用于高效存储和检索字符串数据集中的键。', example: 'Autocomplete (自动补全), Spell Check (拼写检查)。', type: '数据结构' },
  { term: '并查集 (Union-Find)', definition: '处理不交集的合并及查询问题。', example: 'find(x) { return parent[x] == x ? x : (parent[x] = find(parent[x])); }', type: '数据结构' },
  { term: '线段树 (Segment Tree)', definition: '处理区间查询和更新问题。', example: 'Range Sum Query (区间求和), Range Minimum Query (区间最小值)。', type: '数据结构' },
  { term: '红黑树 (Red-Black Tree)', definition: '自平衡二叉搜索树，保证最坏情况 O(log n)。', example: 'Java TreeMap, C++ std::map 的底层实现。', type: '数据结构' },
  { term: 'AVL 树', definition: '最早的自平衡二叉搜索树，严格平衡。', example: '通过旋转操作保持平衡因子在 -1 到 1 之间。', type: '数据结构' },
  { term: 'B+ 树', definition: '多路平衡查找树，所有数据都在叶子节点。', example: 'MySQL InnoDB 索引的底层实现。', type: '数据结构' },
  { term: '图 (Graph)', definition: '节点 (Vertex) 和边 (Edge) 组成。', example: '邻接矩阵 (Adjacency Matrix), 邻接表 (Adjacency List)。', type: '数据结构' },
  { term: 'LRU 缓存 (LRU Cache)', definition: '最近最少使用缓存淘汰策略。', example: 'HashMap + 双向链表。O(1) get/put。', type: '数据结构' },
  { term: '布隆过滤器 (Bloom Filter)', definition: '概率型数据结构，用于判断一个元素是否在一个集合中。', example: '可能误报 (False Positive)，但绝不会漏报 (False Negative)。节省空间。', type: '数据结构' },
  { term: '跳表 (Skip List)', definition: '基于链表的概率性数据结构，支持 O(log n) 的查找、插入、删除。', example: 'Redis ZSet (Sorted Set) 的底层实现之一。', type: '数据结构' },

  // 算法 Algorithms (from structures.js)
  { term: '冒泡排序 (Bubble Sort)', definition: '通过重复交换相邻元素，将最大值“冒泡”到末尾。O(n^2)。', example: 'for (let i = 0; i < n; i++) \n  for (let j = 0; j < n-i-1; j++) \n    if (arr[j] > arr[j+1]) swap(arr, j, j+1);', type: '算法' },
  { term: '快速排序 (Quick Sort)', definition: '分治法，选择基准值 (pivot)，将小于基准的放左边，大于的放右边。平均 O(n log n)。', example: 'function quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  const pivot = arr[0];\n  const left = arr.slice(1).filter(x => x < pivot);\n  const right = arr.slice(1).filter(x => x >= pivot);\n  return [...quickSort(left), pivot, ...quickSort(right)];\n}', type: '算法' },
  { term: '归并排序 (Merge Sort)', definition: '分治法，将数组分成两半，分别排序后合并。稳定 O(n log n)。', example: 'function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  return merge(mergeSort(arr.slice(0, mid)), mergeSort(arr.slice(mid)));\n}', type: '算法' },
  { term: '插入排序 (Insertion Sort)', definition: '构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。O(n^2)。', example: 'for (let i = 1; i < n; i++) { let key = arr[i]; let j = i - 1; while (j >= 0 && arr[j] > key) { arr[j+1] = arr[j]; j--; } arr[j+1] = key; }', type: '算法' },
  { term: '选择排序 (Selection Sort)', definition: '在未排序序列中找到最小元素，存放到排序序列的起始位置。O(n^2)。', example: 'for (let i = 0; i < n-1; i++) { let minIdx = i; for (let j = i+1; j < n; j++) if (arr[j] < arr[minIdx]) minIdx = j; swap(arr, i, minIdx); }', type: '算法' },
  { term: '堆排序 (Heap Sort)', definition: '利用堆这种数据结构所设计的一种排序算法。O(n log n)。', example: '1. 建堆; 2. 交换堆顶元素与末尾元素; 3. 调整堆。', type: '算法' },
  { term: '拓扑排序 (Topological Sort)', definition: '对有向无环图 (DAG) 的顶点进行线性排序。', example: 'Kahn 算法 (入度表), DFS 算法。用于任务调度，依赖解析。', type: '算法' },
  { term: '二分查找 (Binary Search)', definition: '在有序数组中查找元素。O(log n)。', example: 'let low = 0, high = n - 1;\nwhile (low <= high) {\n  let mid = (low + high) >> 1;\n  if (arr[mid] === target) return mid;\n  else if (arr[mid] < target) low = mid + 1;\n  else high = mid - 1;\n}', type: '算法' },
  { term: '深度优先搜索 (DFS)', definition: '沿着树的深度遍历树的节点，尽可能深的搜索树的分支。', example: 'function dfs(node, visited) {\n  if (!node || visited.has(node)) return;\n  visited.add(node);\n  node.neighbors.forEach(n => dfs(n, visited));\n}', type: '算法' },
  { term: '广度优先搜索 (BFS)', definition: '从根节点开始，沿着树的宽度遍历树的节点。', example: 'const q = [start];\nwhile (q.length) {\n  const node = q.shift();\n  node.neighbors.forEach(n => q.push(n));\n}', type: '算法' },
  { term: 'Dijkstra 最短路径', definition: '计算加权图中一个节点到其他所有节点的最短路径 (无负权边)。', example: '使用优先队列 (Min Heap) 优化，每次取距离最小的节点松弛邻边。O(E log V)。', type: '算法' },
  { term: 'Bellman-Ford', definition: '计算单源最短路径，支持负权边。', example: '对所有边进行 V-1 次松弛操作。检测负权环。O(VE)。', type: '算法' },
  { term: 'Floyd-Warshall', definition: '计算所有节点对之间的最短路径。', example: 'for (k) for (i) for (j) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); O(V^3)。', type: '算法' },
  { term: 'Prim 最小生成树', definition: '贪心算法，从一个节点开始，每次选择连接已访问集合和未访问集合的最小边。', example: '类似 Dijkstra。O(E log V)。', type: '算法' },
  { term: 'Kruskal 最小生成树', definition: '贪心算法，按边权从小到大排序，使用并查集避免环。', example: 'sort(edges); for (e in edges) if (find(u) != find(v)) union(u, v); O(E log E)。', type: '算法' },
  { term: 'KMP 算法', definition: 'Knuth-Morris-Pratt 字符串查找算法，利用匹配失败后的信息，尽量减少模式串与主串的匹配次数。', example: '构建 next 数组 (LPS)，O(N+M)。', type: '算法' },
  { term: 'Rabin-Karp', definition: '利用哈希函数进行字符串查找。', example: '滚动哈希 (Rolling Hash)。O(N+M) 平均，O(NM) 最坏。', type: '算法' },
  { term: '动态规划 (DP)', definition: '将复杂问题分解为子问题，保存子问题的解以避免重复计算。', example: '斐波那契数列: dp[i] = dp[i-1] + dp[i-2];\n0/1 背包问题: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i]);', type: '算法' },
  { term: '贪心算法 (Greedy)', definition: '在每一步选择中都采取在当前状态下最好或最优的选择。', example: '活动选择问题，Huffman 编码，Prim/Kruskal 最小生成树算法。', type: '算法' },
  { term: '回溯算法 (Backtracking)', definition: '通过探索所有可能的候选解来找出所有的解。', example: 'N 皇后问题，全排列，数独求解。', type: '算法' },
  { term: '分治法 (Divide and Conquer)', definition: '将问题分解为规模较小的子问题，递归解决子问题，然后合并结果。', example: '归并排序，快速排序，Strassen 矩阵乘法。', type: '算法' }
];
